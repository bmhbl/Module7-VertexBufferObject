//#define GLEW_STATIC
#include<iostream>
#include<thread>
#include<GL/glew.h>
#include<GL/freeglut.h>

using namespace std;

void display();
void triangle();
GLuint VBOid;
GLuint vindices;
GLuint vcolors;
void onExit(unsigned char key, int x, int y);
void animateTopTriangle(int value);

bool triangleUpdate = false;
int framecounter = 0;
GLfloat* mappedVertices = NULL;

int main(int argc, char** argv) {

    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowPosition(100, 100); //Pixel Position
    glutInitWindowSize(800, 600);
    glutCreateWindow("Module 6");
    glutDisplayFunc(display);
    glutKeyboardFunc(onExit);

    GLenum err = glewInit();
    if (err == GLEW_OK)
        glutMainLoop();
    else
    {
        cout << "unable to initilize";
    }

}

void triangle() {
    if (!triangleUpdate) {
        GLfloat trianglevertices[] = {
            0.0f, .75f,
            -0.75f, 0.0f,
            0.75f,0.0f,

            -0.75f, -0.75f,
            0.0f, 0.0f,
            0.75f, -0.75f

        };

        GLfloat colorvertices[] = {
            1.0f,0.0f,0.0f,
            1.0f,0.0f,0.0f,
            1.0f,0.0f,0.0f,

            0.0f,1.0f,0.0f,
            0.0f,1.0f,0.0f,
            0.0f,1.0f,0.0f,

        };

        GLubyte triangleindices[] = {
            0,1,2,3,4,5,0,5
        };


        glGenBuffers(1, &VBOid);
        glBindBuffer(GL_ARRAY_BUFFER, VBOid);
        glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * 12, trianglevertices, GL_STATIC_DRAW);
        glVertexPointer(2, GL_FLOAT, 0, 0);//last 0 means it will get the data from the video card.  This also describe your vertices


        glGenBuffers(1, &vindices);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, vindices);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLubyte) * 8, triangleindices, GL_STATIC_DRAW);
        glNormalPointer(GL_UNSIGNED_BYTE, 0, 0);//describes the pointers


        glGenBuffers(1, &vcolors);
        glBindBuffer(GL_ARRAY_BUFFER, vcolors);
        glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat) * 18, colorvertices, GL_STATIC_DRAW);
        glColorPointer(3, GL_FLOAT, 0, 0); // this describes the color pointer
    }
    else
    {
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, 0); //this draws the triangle
        glDrawElements(GL_LINES, 2, GL_UNSIGNED_BYTE, (void*)(sizeof(GLubyte) * 6)); //this draws the lines
    }
    cout << "Frame no: " << framecounter;
}


void display() {

    glClear(GL_COLOR_BUFFER_BIT);
    framecounter++;

    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);

    triangle();
    //do more figure

    glDisableClientState(GL_VERTEX_ARRAY);
    glDisableClientState(GL_COLOR_ARRAY);

    glutSwapBuffers(); //first display
    glutTimerFunc(1000, animateTopTriangle, 0);
}

void animateTopTriangle(int value)
{
    triangleUpdate = true;
    cout << "updated values.." << endl;

    glBindBuffer(GL_ARRAY_BUFFER, VBOid);
    mappedVertices = (GLfloat*)glMapBuffer(GL_ARRAY_BUFFER, GL_READ_WRITE);
    mappedVertices[0] += 0.01f;
    mappedVertices[2] += 0.01f;
    mappedVertices[4] += 0.01f;

    mappedVertices[6] -= 0.01f;
    mappedVertices[8] -= 0.01f;
    mappedVertices[10] -= 0.01f;

    cout << mappedVertices[0] << endl;
    glUnmapBuffer(GL_ARRAY_BUFFER);

    glBindBuffer(GL_ARRAY_BUFFER, vcolors);
    mappedVertices = (GLfloat*)glMapBuffer(GL_ARRAY_BUFFER, GL_READ_WRITE);
    mappedVertices[2] += 0.1f;
    mappedVertices[5] += 0.1f;
    mappedVertices[8] += 0.1f;

    mappedVertices[9] += 0.1f;
    mappedVertices[12] += 0.1f;
    mappedVertices[15] += 0.1f;
    cout << mappedVertices[0] << endl;
    glUnmapBuffer(GL_ARRAY_BUFFER);

    glutPostRedisplay();
}
void onExit(unsigned char key, int x, int y)
{
    if (key == 27)
    {
        //when working with vertex_buffer_objects, deallocation it from the memory
        glBindBuffer(GL_ARRAY_BUFFER, 0); //this line switches back to normal pointer operation
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
        glDeleteBuffers(1, &VBOid);
        glDeleteBuffers(1, &vindices);
        glDeleteBuffers(1, &vcolors);

        exit(0);
    }
}